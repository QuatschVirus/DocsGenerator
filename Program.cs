using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections;
using System.Diagnostics;
using System.Security.AccessControl;
using System.Xml;
using System.Xml.Linq;
using System.CodeDom;
using Microsoft.CSharp;
using System.Collections.Frozen;


namespace DocsGenerator
{
    public static class Program
    {
        const string credits = "\n---\n*Generated by [DocsGenerator](https://github.com/QuatschVirus/DocsGenerator)*";

        static Dictionary<string, TypeRecord> typeRecords = new();

        static void Main(string[] args)
        {
            string[] htmlExtensions = new string[] { ".html", ".htm", ".php", ".aspx", "asp", ".jsp" };

            string inPath = args.Length > 0 ? args[0] : "./docs.xml";
            string outPath = args.Length > 1 ? args[1] : "";
            List<string> classes = args.Where(a => a.StartsWith('-')).ToList();
            bool outputHTML = htmlExtensions.Contains(Path.GetExtension(outPath)) || args.Any(a => a.ToLower() == "/h");
            bool includePrivate = args.Any(a => a.ToLower() == "/p");

            XDocument doc = XDocument.Load(inPath);
            XElement[] members = doc.Root.Descendants("member").ToArray();

            foreach (var type in members.Where(m => m.Attribute("name")?.Value.StartsWith('T') ?? false))
            {
                TypeRecord t = new(type);
                typeRecords.Add(t.CRef.Qualified, t);
            }

            foreach (var field in members.Where(m => m.Attribute("name")?.Value.StartsWith('F') ?? false))
            {
                FieldRecord f = new(field);
                string parent = f.CRef.ParentQualifier;
                if (typeRecords.TryGetValue(parent, out TypeRecord value))
                {
                    value.Members.Add(f);
                } else
                {
                    TypeRecord empty = new(parent, f.Scope, TypeKind.Unkown);
                    empty.Members.Add(f);
                    typeRecords.Add(parent, empty);
                }
            }

            foreach (var property in members.Where(m => m.Attribute("name")?.Value.StartsWith('P') ?? false))
            {
                PropertyRecord p = new(property);
                string parent = p.CRef.ParentQualifier;
                if (typeRecords.TryGetValue(parent, out TypeRecord value))
                {
                    value.Members.Add(p);
                }
                else
                {
                    TypeRecord empty = new(parent, p.Scope, TypeKind.Unkown);
                    empty.Members.Add(p);
                    typeRecords.Add(parent, empty);
                }
            }

            foreach (var method in members.Where(m => m.Attribute("name")?.Value.StartsWith('M') ?? false))
            {
                MethodRecord m = new(method);
                string parent = m.CRef.ParentQualifier;
                if (typeRecords.TryGetValue(parent, out TypeRecord value))
                {
                    value.Members.Add(m);
                }
                else
                {
                    TypeRecord empty = new(parent, m.Scope, TypeKind.Unkown);
                    empty.Members.Add(m);
                    typeRecords.Add(parent, empty);
                }
            }

            string assembly = doc.Root.Element("assembly").Element("name").Value;
            string path = Path.Combine(outPath, assembly);

            Directory.CreateDirectory(path);

            foreach (var r in typeRecords.Values)
            {
                File.WriteAllText(Path.Combine(path, r.CRef.Name + ".md"), r.ToString());
            }
        }

        public static string XMLToMD(XElement root)
        {
            // Temporary for dev
            return root?.Value;
        }

        public static string Capitalise(this string source)
        {
            return source[..1].ToUpper() + source[1..];
        }
    }

    public class Record
    {
        public CRef CRef;
        public Scope Scope;

        protected readonly XElement raw;

        public XElement Summary => raw?.Element("summary");
        public XElement Remarks => raw?.Element("remarks");

        public Record(XElement raw)
        {
            CRef = CRef.FromString(raw.Attribute("name").Value);

            Scope = Enum.Parse<Scope>(raw.Element("scope")?.Value?.Capitalise() ?? Scope.Public.ToString());

            this.raw = raw;
        }

        public Record(string reference, Scope scope)
        {
            CRef = CRef.FromString(reference);
            Scope = scope;
            raw = null;
        }
    }

    public enum TypeKind
    {
        Class,
        Struct,
        Enum,
        Abstract,
        Interface,
        Static,
        Attribute,
        Unkown
    }

    public enum Scope
    {
        Public,
        Protected,
        Private,
        Internal
    }

    public class TypeRecord : Record
    {
        public TypeKind typeKind;
        public List<Record> Members = new();

        public CRef Extends;
        public List<CRef> Implements = new();

        public TypeRecord(XElement raw) : base(raw)
        {
            typeKind = Enum.Parse<TypeKind>(raw.Element("kind")?.Value?.Capitalise() ?? TypeKind.Class.ToString());

            Extends = CRef.FromString(raw.Element("extends")?.Attribute("cref")?.Value);
            Implements = raw.Elements("implements").Where(e => e.Attribute("cref") != null).Select(e => CRef.FromString(e.Attribute("cref").Value)).ToList();
        }

        public TypeRecord(string reference, Scope scope, TypeKind typeKind) : base(reference, scope)
        {
            this.typeKind = typeKind;
        }

        public override string ToString()
        {
            string typeparams = string.Empty;
            if (raw != null)
            {
                typeparams = "<";
                foreach (XElement e in raw.Elements("typeparam"))
                {
                    if (typeparams != "<") typeparams += ", ";
                    typeparams += e.Attribute("name")?.Value ?? "";

                }
                typeparams += ">";
                if (typeparams.Length <= 2) typeparams = string.Empty;
            }

            string output = $"# {Scope.ToString().ToLower()} {CRef.Name}{typeparams} ({typeKind})\n";
            output += "`" + CRef.Qualified + "`  \n";
            if (Extends != null) output += $"> *extends {Extends.Qualified}*  \n";
            foreach (var imp in Implements) output += $"> *implements {imp.Qualified}*  \n";
            output += "\n";

            output += (Program.XMLToMD(Summary)?.Trim() ?? "*No summary provided*") + "\n\n";
            if (Remarks != null) output += Program.XMLToMD(Remarks);

            if (typeKind == TypeKind.Enum)
            {
                output += "\n## Values\n";

                foreach (FieldRecord r in Members.OfType<FieldRecord>())
                {
                    output += $"\n### {r.CRef.Name}\n";
                    output += (Program.XMLToMD(r.Summary)?.Trim() ?? "*No summary provided*") + "\n\n";
                    if (r.Remarks != null) output += Program.XMLToMD(r.Remarks);
                }
            }
            else
            {
                output += "\n## Fields\n";
                foreach (FieldRecord r in Members.OfType<FieldRecord>())
                {
                    output += r.ToString();
                }

                output += "\n## Properties\n";
                foreach (PropertyRecord r in Members.OfType<PropertyRecord>())
                {
                    output += r.ToString();
                }

                output += "\n## Methods\n";
                foreach (MethodRecord r in Members.OfType<MethodRecord>())
                {
                    output += r.ToString();
                }
            }

            return output;
        }
    }

    public class FieldRecord : Record
    {
        public CRef Type;
        public bool ReadOnly;
        public bool Static;

        public FieldRecord(XElement raw) : base(raw)
        {
            Type = CRef.FromString(raw.Element("type")?.Attribute("cref")?.Value, true);
            ReadOnly = raw.Element("readonly") != null;
            Static = raw.Element("static") != null;
        }

        public override string ToString()
        {
            string output = $"### {Scope.ToString().ToLower()} ";
            if (Static) output += "static ";
            if (ReadOnly) output += "readonly ";
            output += Type.Name + " ";
            output += CRef.Name + "\n";

            output += (Program.XMLToMD(Summary)?.Trim() ?? "*No summary provided*") + "\n\n";
            if (Remarks != null) output += Program.XMLToMD(Remarks);

            return output;
        }
    }

    public class PropertyRecord : Record
    {
        public CRef Type;
        public bool Static;
        public bool Abstract;
        public bool ReadOnly;

        public Scope GetterScope;
        public Scope SetterScope;

        public CRef Overrides;

        public PropertyRecord(XElement raw) : base(raw)
        {
            Type = CRef.FromString(raw.Element("type")?.Attribute("cref")?.Value, true);
            Static = raw.Element("static") != null;
            Abstract = raw.Element("abstract") != null;
            ReadOnly = raw.Element("readonly") != null;

            GetterScope = Enum.Parse<Scope>(raw.Element("getterScope")?.Value?.Capitalise() ?? Scope.ToString());
            SetterScope = Enum.Parse<Scope>(raw.Element("setterScope")?.Value?.Capitalise() ?? Scope.ToString());

            Overrides = CRef.FromString(raw.Element("overrides")?.Attribute("cref")?.Value);
        }

        public override string ToString()
        {
            string output = $"### {Scope.ToString().ToLower()} ";
            if (Static) output += "static ";
            if (Abstract) output += "abstract ";
            output += Type.Name + " ";
            output += CRef.Name;
            if (!ReadOnly)
            {
                output += " { ";
                output += GetterScope != Scope ? GetterScope.ToString().ToLower() + " get; " : "get; ";
                output += SetterScope != Scope ? SetterScope.ToString().ToLower() + " set; " : "set; ";
                output += "}";
            }
            output += "\n";
            if (Overrides != null) output += $"> *overrides {Overrides.QualifiedSignature}*\n\n";

            output += (Program.XMLToMD(Summary)?.Trim() ?? "*No summary provided*") + "\n\n";
            if (Remarks != null) output += Program.XMLToMD(Remarks);

            return output;
        }
    }

    public class MethodRecord : Record
    {
        public XElement Return;
        public MethodKind Kind;

        public CRef Type => CRef.FromString(Return?.Attribute("cref")?.Value, true);

        public List<ParameterSignature> Parameters = new();

        public CRef Overrides;

        public MethodRecord(XElement raw) : base(raw)
        {
            ParameterCRef c = CRef as ParameterCRef;

            Return = raw.Element("returns");
            MethodKind fallback = MethodKind.Standard;
            if (CRef.Name.Contains("op_"))
            {
                fallback = MethodKind.Operator;
                if (CRef.Name == "op_Explicit")
                {
                    fallback = MethodKind.ExplicitOperator;
                } else if (CRef.Name == "op_Implicit")
                {
                    fallback = MethodKind.ImplicitOperator;
                }
            }
            Kind = Enum.Parse<MethodKind>(raw.Element("kind")?.Value?.Capitalise() ?? fallback.ToString());
            XElement[] p = raw.Elements("param").ToArray();
            if (c != null)
            {
                for (int i = 0; i < c.Parameters.Length; i++)
                {
                    if (p.Length > i && c.Parameters.Length > i)
                    {
                        Parameters.Add(new(c.Parameters[i], p[i]));
                    }
                }
            }

            Overrides = CRef.FromString(raw.Element("overrides")?.Attribute("cref")?.Value);
        }

        public override string ToString()
        {
            string output = $"### ";

            output += Kind switch
            {
                MethodKind.Standard => $"{Scope.ToString().ToLower()} {Type.ShorthandName} {CRef.ParseMethodSignature(CRef, Parameters)}",
                MethodKind.Virtual => $"{Scope.ToString().ToLower()} virtual {Type.ShorthandName} {CRef.ParseMethodSignature(CRef, Parameters)}",
                MethodKind.Override => $"{Scope.ToString().ToLower()} override {Type.ShorthandName} {CRef.ParseMethodSignature(CRef, Parameters)}",
                MethodKind.Abstract => $"{Scope.ToString().ToLower()} abstract {Type.ShorthandName} {CRef.ParseMethodSignature(CRef, Parameters)}",
                MethodKind.Static => $"{Scope.ToString().ToLower()} static {Type.ShorthandName} {CRef.ParseMethodSignature(CRef, Parameters)}",
                MethodKind.Extension => $"{Type.ShorthandName} {CRef.ParseMethodSignature(CRef, Parameters, true)} (Extension)",
                MethodKind.Operator => $"{CRef.ParseMethodSignature(CRef, Parameters)} = {Type.ShorthandName}",
                MethodKind.ImplicitOperator => $"Implicit conversion of {CRef.GetShorthandType(Parameters.First().Type)} to {Type.ShorthandName}",
                MethodKind.ExplicitOperator => $"Explicit conversion (cast) of {CRef.GetShorthandType(Parameters.First().Type)} to {Type.ShorthandName}",
                _ => $"{Scope.ToString().ToLower()} {Type.ShorthandName} {CRef.ParseMethodSignature(CRef, Parameters)}"
            };

            output += "\n";
            if (Overrides != null) output += $"> *overrides {Overrides.QualifiedSignature}*\n\n";

            output += (Program.XMLToMD(Summary)?.Trim() ?? "*No summary provided*") + "\n\n";
            if (Remarks != null) output += Program.XMLToMD(Remarks) + "\n";

            foreach (var p in Parameters)
            {
                output += p.Documentation + "\n";
            }

            return output;
        }
    }

    public enum MethodKind
    {
        Standard,
        Virtual,
        Override,
        Abstract,
        Static,
        Extension,
        Operator,
        ExplicitOperator,
        ImplicitOperator
    }

    public class ParameterSignature
    {
        public string Type;
        public XElement raw;

        public string Signature => CRef.GetShorthandType(Type) + " " + raw.Attribute("name").Value;
        public string Documentation => $"#### " + Signature + "\n" + Program.XMLToMD(raw) + "\n\n";

        public ParameterSignature(string type, XElement raw)
        {
            Type = type;
            this.raw = raw;
        }
    }

    public class CRef
    {
        static readonly Dictionary<string, string> operatorMapping = new()
        {
            ["op_Addition"] = "+",
            ["op_Subtraction"] = "-",
            ["op_Multiply"] = "*",
            ["op_Division"] = "/",
            ["op_Modulus"] = "%",
            ["op_BitwiseAnd"] = "&",
            ["op_BiwiseOr"] = "|",
            ["op_LeftShift"] = "<<",
            ["op_RightShift"] = ">>",
            ["op_LessThan"] = "<",
            ["op_GreaterThan"] = ">",
            ["op_LogicalAnd"] = "&&",
            ["op_LogicalOr"] = "||",
            ["op_Xor"] = "^",
            ["op_Equality"] = "==",
            ["op_Inequality"] = "!=",

            ["op_UnaryNegation"] = "-",
            ["op_UnaryPlus"] = "+",
            ["op_UnaryMinus"] = "-",
            ["op_OnesComplement"] = "~",

            ["op_Implicit"] = "Implicit conversion to",
            ["op_Explicit"] = "Explicit conversion (cast) to"
        };

        public string Reference;
        public CRefKind Kind;
        public string Qualified;
        public string Name;
        public string Trivia;

        public static CRefKind FromLeadingChar(char c)
        {
            return c switch
            {
                'N' => CRefKind.Namespace,
                'T' => CRefKind.Type,
                'F' => CRefKind.Field,
                'P' => CRefKind.Property,
                'M' => CRefKind.Method,
                'E' => CRefKind.Event,
                _ => CRefKind.Type
            };
        }

        public CRef(string reference)
        {
            Reference = reference;
            if (reference[1] == ':')
            {
                Kind = FromLeadingChar(reference[0]);
                Qualified = string.Concat(reference.Skip(2).TakeWhile(c => c != '('));
                Name = Qualified.Split('.').Last();
                Trivia = reference[(2 + Qualified.Length)..];
            } else
            {
                Kind = CRefKind.Type;
                Qualified = string.Concat(reference.TakeWhile(c => c != '('));
                Name = Qualified.Split('.').Last();
                Trivia = reference[Qualified.Length..];
            }
        }

        public string ParentQualifier => string.Concat(Qualified.SkipLast(Name.Length + 1));

        public virtual string Signature => Name + Trivia;
        public virtual string QualifiedSignature => Qualified + Trivia;

        public string ShorthandName => GetShorthandType(Qualified);

        public static CRef FromString(string reference, bool force = false)
        {
            if (reference == null)
            {
                if (force)
                {
                    reference = "System.Object";
                } else
                {
                    return null;
                }
            }
            
            CRef basic = new(reference);
            if (basic.Kind == CRefKind.Property || basic.Kind == CRefKind.Method)
            {
                if (basic.Trivia.Contains('(') && basic.Trivia.Contains(')'))
                {
                    basic = new ParameterCRef(reference);

                    if (basic.Trivia.Contains('~'))
                    {
                        basic = new ConversionCRef(reference);
                    }
                }
            }

            return basic;
        }

        public static string GetShorthandType(string qualified)
        {
            using CSharpCodeProvider provider = new();
            CodeTypeReference reference = new(qualified);
            return provider.GetTypeOutput(reference);
        }

        public static string ParseMethodSignature(ParameterCRef cref, bool asExtension = false)
        {
            if (operatorMapping.TryGetValue(cref.Name, out var rep))
            {
                if (cref is ConversionCRef c)
                {
                    return rep + " " + GetShorthandType(c.ReturnType);
                }
                else
                {
                    if (cref.Parameters.Length > 1)
                    {
                        return GetShorthandType(cref.Parameters[0]) + " " + rep + " " + GetShorthandType(cref.Parameters[1]);
                    }
                    else
                    {
                        return rep + GetShorthandType(cref.Parameters[0]);
                    }
                }
            } else if (cref.Name == "#ctor")
            {
                return "Constructor (" + string.Join(", ", cref.Parameters.Select(GetShorthandType)) + ")";
            } else if (asExtension)
            {
                return GetShorthandType(cref.Parameters.First()) + "." + cref.Name + "(" + string.Join(", ", cref.Parameters.Skip(1).Select(GetShorthandType)) + ")";
            } else 
            {
                return cref.Name + "(" + string.Join(", ", cref.Parameters.Select(GetShorthandType)) + ")";
            }
        }

        public static string ParseMethodSignature(CRef cref, List<ParameterSignature> sigs, bool asExtension = false)
        {
            if (operatorMapping.TryGetValue(cref.Name, out var rep))
            {
                if (sigs.Count > 1)
                {
                    return  "(" + sigs[0].Signature + ") " + rep + " (" + sigs[1].Signature + ")";
                }
                else
                {
                    return rep + "(" + sigs[0].Signature + ")";
                }
            } else if (cref.Name == "#ctor")
            {
                return "Constructor (" + string.Join(", ", sigs.Select(s => s.Signature)) + ")";
            } else if (asExtension)
            {
                return GetShorthandType(sigs.First().Type) + "." + cref.Name + "(" + string.Join(", ", sigs.Skip(1).Select(s => s.Signature)) + ")";
            } else 
            {
                return cref.Name + "(" + string.Join(", ", sigs.Select(s => s.Signature)) + ")";
            }
        }
    }

    public class ParameterCRef : CRef
    {
        public string[] Parameters = Array.Empty<string>();

        public ParameterCRef(string reference) : base(reference)
        {
            int start = Trivia.IndexOf('(') + 1;
            int end = Trivia.IndexOf(')');
            Parameters = Trivia[start..end].Split(',');
        }

        public override string Signature => ParseMethodSignature(this);
        public override string QualifiedSignature => ParentQualifier + "." + Signature;
    }

    public class ConversionCRef : ParameterCRef
    {
        public string ReturnType;

        public ConversionCRef(string reference) : base(reference)
        {
            ReturnType = Trivia[(Trivia.LastIndexOf('~') + 1)..];
        }
    }

    public enum CRefKind
    {
        Namespace,
        Type,
        Field,
        Property,
        Method,
        Event
    }
}