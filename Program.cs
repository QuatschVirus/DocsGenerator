using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Xml;
using System.Xml.Linq;
using System.Collections.Frozen;
using System.Text.Json.Serialization;
using System.Text.Json;
using System.IO;

namespace DocsGenerator
{
    public static class Program
    {
        const string credits = "\n---\n*Generated by [DocsGenerator](https://github.com/QuatschVirus/DocsGenerator)*";
        const string configPath = "dg-cfg.json";

        static JsonElement config;

        public static SyntaxTree[] trees;
        public static UnifiedTree<Record> records = new("Code Dcoumentation");

        static void Main(string[] args)
        {
            string basepath = (args.Length > 0) ? args[0] : ".";
            string cp = Path.Combine(basepath, configPath);
            if (File.Exists(cp)) {
                config = JsonSerializer.Deserialize<JsonElement>(File.ReadAllText(cp));
            }
            Console.WriteLine("Welcome to DocsGenerator! Config loaded, beginning import...");

            string[] files = Directory.GetFiles(basepath, "*.cs", SearchOption.AllDirectories);
            Console.WriteLine($"Found {files.Length} files to index");
            trees = files.Select(p => CSharpSyntaxTree.ParseText(File.ReadAllText(p))).ToArray();
            Console.WriteLine($"Import complete, imported {trees.Length} syntax tress. Beginning indexing");

            DocumentationWalker walker = new();
            foreach (var t in trees)
            {
                walker.Visit(t.GetRoot());
            }
            Console.WriteLine($"Indexing complete, found {records.Count} records");
        }
    }

    public class DocumentationWalker : CSharpSyntaxWalker
    {
        public override void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
        {
            var n = node.ParentTrivia.Token.Parent;
            if (n is not MemberDeclarationSyntax) n = n.Parent;
            var m = n as MemberDeclarationSyntax;
            Scope s = GetScope(m);
            RecordKind k = GetKind(m);
            Identifier i = GetIdentifier(m);
            Flags f = GetFlags(m);
            string signature = GetSignature(m);

            Console.WriteLine($"{s} {k} {i} ({f}) [{signature}]");
            string xml = node.ToString().Replace("///", "");
            XmlDocument doc = new();
            doc.LoadXml(xml);
            Console.WriteLine(xml);

            Record r = new(i, k, s, f, signature, doc.ChildNodes);
            Program.records.AddNode(i.Qualifier, new(i.Name, r, Program.records));
        }

        public DocumentationWalker() : base(SyntaxWalkerDepth.StructuredTrivia) { }

        public static string GetSignature(MemberDeclarationSyntax m)
        {
            string basic = m.WithAttributeLists(new SyntaxList<AttributeListSyntax>()).ToString();

            int semiColonIndex = basic.IndexOf(';');
            int equalsIndex = basic.IndexOf("=");
            int bracketIndex = basic.IndexOf("{");
            int stopIndex = Math.Min(Math.Min(semiColonIndex > 0 ? semiColonIndex : basic.Length, equalsIndex > 0 ? equalsIndex : basic.Length), bracketIndex > 0 ? bracketIndex : basic.Length);

            return basic[..stopIndex].Trim();
        }
        public static string GetQualifiedName(SyntaxNode n)
        {
            string name = n switch
            {
                CompilationUnitSyntax => "",
                NamespaceDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.Name,
                ClassDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.Identifier,
                EnumDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.Identifier,
                InterfaceDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.Identifier,
                DelegateDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.Identifier,
                EventDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.Identifier,
                MethodDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.Identifier,
                PropertyDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.Identifier,
                FieldDeclarationSyntax s => GetQualifiedName(s.Parent) + "." + s.DescendantTokens().Where(t => t.IsKind(SyntaxKind.IdentifierToken)).First(),
                _ => GetQualifiedName(n.Parent)
            };
            return name.Trim().Trim('.');
        }

        public static Identifier GetIdentifier(SyntaxNode n) => new(GetQualifiedName(n));

        public static RecordKind GetKind(MemberDeclarationSyntax m)
        {
            return m switch
            {
                NamespaceDeclarationSyntax => RecordKind.Namespace,
                ClassDeclarationSyntax => RecordKind.Class,
                EnumDeclarationSyntax => RecordKind.Enum,
                InterfaceDeclarationSyntax   => RecordKind.Interface,
                DelegateDeclarationSyntax => RecordKind.Delegate,
                EventDeclarationSyntax => RecordKind.Event,
                MethodDeclarationSyntax => RecordKind.Method,
                PropertyDeclarationSyntax => RecordKind.Property,
                FieldDeclarationSyntax => RecordKind.Field,
                EnumMemberDeclarationSyntax => RecordKind.EnumMember,
                _ => RecordKind.Unkown
            };
        }

        public static Scope GetScope(MemberDeclarationSyntax m)
        {
            if (m is EnumMemberDeclarationSyntax)
            {
                return GetScope(m.Parent as EnumDeclarationSyntax);
            }
            var firstToken = m.ChildNodesAndTokens().ToList().Find(s => s.IsToken);
            return firstToken.Kind() switch
            {
                SyntaxKind.PublicKeyword => Scope.Public,
                SyntaxKind.PrivateKeyword => Scope.Private,
                SyntaxKind.ProtectedKeyword => Scope.Protected,
                SyntaxKind.InternalKeyword => Scope.Internal,
                _ => Scope.Private
            };
        }

        public static Flags GetFlags(MemberDeclarationSyntax m)
        {
            Flags output = Flags.None;
            var tokens = m.ChildTokens();
            
            if (tokens.Any(t => t.IsKind(SyntaxKind.AbstractKeyword))) output |= Flags.Abstract;
            if (tokens.Any(t => t.IsKind(SyntaxKind.StaticKeyword))) output |= Flags.Static;
            if (tokens.Any(t => t.IsKind(SyntaxKind.OverrideKeyword))) output |= Flags.Override;
            if (tokens.Any(t => t.IsKind(SyntaxKind.VirtualKeyword))) output |= Flags.Virtual;
            if (m.ChildNodes().Any(n => n.IsKind(SyntaxKind.TypeParameterList))) output |= Flags.Generic;

            if (m is MethodDeclarationSyntax)
            {
                ParameterListSyntax p = m.ChildNodes().OfType<ParameterListSyntax>().First();
                if (p.DescendantTokens().Any(t => t.IsKind(SyntaxKind.ThisKeyword))) output |= Flags.Extension;
            }

            return output;
        }
    }

    public class Identifier
    {
        private readonly string[] split;
        public readonly string Qualifier;
        public readonly string Name;

        public string TraverseUp(int depth, bool asPath = false)
        {
            return string.Join(asPath ? '/' : '.', split.SkipLast(depth));
        }

        public string TraverseDown(int depth, bool asPath = false)
        {
            return string.Join(asPath ? '/' : '.', split.Take(depth));
        }

        public int Size => split.Length;

        public Identifier(string raw)
        {
            Qualifier = raw;
            split = Qualifier.Split('.');
            Name = split.Last();
        }

        public override string ToString()
        {
            return Qualifier;
        }
    }

    public class Record
    {
        public readonly Identifier Identifier;
        public readonly RecordKind Kind;
        public readonly Scope Scope;
        public readonly Flags Flags;

        public readonly string Signature;

        public readonly XmlNodeList documentation = new();

        public bool HasFlag(Flags flag) => Flags.HasFlag(flag);

        public Record(Identifier identifier, RecordKind kind, Scope scope, Flags flags, string signature, XmlNodeList documentation)
        {
            Identifier = identifier;
            Kind = kind;
            Scope = scope;
            Flags = flags;
            Signature = signature;
            this.documentation = documentation;
        }
    }

    public enum RecordKind
    {
        Unkown,
        Namespace,
        Class,
        Enum,
        Interface,
        Delegate,
        Event,
        Method,
        Property,
        Field,
        EnumMember
    }

    public enum Scope
    {
        Public,
        Protected,
        Private,
        Internal
    }

    [Flags]
    public enum Flags
    {
        None = 0,
        Static = 1,
        Abstract = 2,
        Override = 4,
        Virtual = 8,
        Generic = 16,
        Extension = 32
    }
}